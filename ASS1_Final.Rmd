---
title: "Asset Allocation Assignment 1"
author: 
date: "`r Sys.Date()`"
output:
  pdf_document:
    number_sections: yes
    fig_caption: yes
  html_document:
    df_print: paged
    toc: yes
    toc_float: yes
    toc_depth: 2
    number_sections: yes
  html_notebook:
    df_print: paged
    toc: yes
---

\newpage
\tableofcontents
\newpage


# Load libraries
```{r,message=FALSE}
library(readxl)
library(xts)
library(openxlsx)
library(dplyr)
library(quantmod)
library(zoo)
library(mnormt)
library(moments)
```

# Calculating Returns Statistics
First of all, the original data were cleaned and sorted as data frame. In addition, index prices were converted from local currencies to USD for better manipulation in the following analysis. 
```{r}
# load price data
price <- read_excel("PS1_data.xls",sheet ="hard_copy", skip = 2)
price <- price[c(4:12)]

# load exchange rate data
exchange_rate <- read_excel("PS1_data.xls", sheet ="hard_copy",skip = 2)
exchange_rate <- exchange_rate[c(14:21)]
exchange_rate <- cbind(price[,1],exchange_rate) # combine first col of price df with exchange rate df

price <- as.data.frame(price)
exchange_rate <- as.data.frame(exchange_rate)
exchange_rate <- setNames(exchange_rate, c("date","TSX","CAC","DAX","Euro50","NIKKEI","FTSE","SP500","IBOVESPA")) # setNames()

# get total date
n = as.numeric(nrow(price))

# convert price to dollar
price $TSX <- price$TSX*exchange_rate$TSX
price $CAC <- price$CAC*exchange_rate$CAC
price $DAX <- price$DAX*exchange_rate$DAX
price $Eurostoxx50 <- price$Eurostoxx50*exchange_rate$Euro50
price $NIKKEI225 <- price$NIKKEI225*exchange_rate$NIKKEI
price $FTSE100 <- price$FTSE100*exchange_rate$FTSE
price $SP500 <- price$SP500*exchange_rate$SP500
price $IBOVESPA<- price$IBOVESPA*exchange_rate$IBOVESPA
```
## Calculating daily returns
Since the stock market did not open on weekends and other holidays, we adjusted those values by deleting the rows where the returns are 0. 
```{r}
daily_return <- (price[-1,-1]-price[-n,-1])/price[-n,-1]
daily_return <- cbind(price$date[-1],daily_return)
# remove the row where all returns are 0
daily_return <- daily_return[!rowSums(daily_return[,-1]) == 0,] 
colnames(daily_return)[1]="date"
# modify the date column as class date
daily_return$date <- as.Date(daily_return$date, "%Y/%m/%d")
```
## Calculating log daily returns
Daily returns were converted to log returns and below showed daily log returns for each index, using the following formula:
$$log\_return_t = log(\frac{p_t}{p_{t-1}})$$
```{r}
log_daily_return <- log(price[-1,-1]/price[-n,-1])
log_daily_return <- cbind(price$date[-1],log_daily_return)
log_daily_return <- log_daily_return[!rowSums(log_daily_return[,-1]) == 0,]

colnames(log_daily_return)[1]="date"
log_daily_return$date <- as.Date(log_daily_return$date, "%Y/%m/%d")
#log_daily_return <- replace(log_daily_return, log_daily_return==1, NA)
log_daily_return

```
## Calculating mean of log return of each index
From the results shown below, TSX, DAX, SP500 and IBOVESPA had average log return greater than 1 meaning that their average returns were positive. In contrast, the other indexes had negative returns.
```{r}
mean <- colMeans(log_daily_return[,-1]) 
mean
```

## Calculating standard deviation of every index
Standard deviation for SP500 was the smallest among all indexes, implying that SP500 tended to be less volatile than the other indexes. 
```{r}
std_dev = apply(log_daily_return[,-1], 2, sd) # 2 refers to columns
std_dev
```

## Calculating skewness of every index
Apart from CAC, the other indexes were negatively skewed which indicated that investors may encounter frequent small gains from most indexes but there were possibilities for huge negative returns. 
```{r}
ske <- apply(log_daily_return[,-1], 2, skewness) 
ske
```
## Calculating kurtosis of every index 
All indexes had kurtosis being far from 0 which demonstrate that distributions for returns had fat tails for all indexes. Therefore, under high kurtosis distribution, it was possible for investors to experience extreme returns. 
```{r}
kurtosis = apply(log_daily_return[,-1], 2, kurtosis)
kurtosis
```

## Autocorrelation of each index
Graphs showed weak autocorrelations for long term.
```{r}
# autocorrelation for each index
auto_cor = apply(log_daily_return[,-1], 2, acf)

# Convert data frame to time series 
data_xts <- xts(log_daily_return, order.by = as.Date(log_daily_return$date),format = '%Y-%m-%d' )
returns_daily_xts <- na.omit(data_xts[,-1]) # remove rows with NA values

# Plot autocorrelation for each index 
title <- c( "TSX","CAC","CAC","Eurostoxx50", "NIKKEI225","FTSE100","SP500","IBOVESPA")
par(mfrow = c(4, 4))  
for (i in 1:8) {
  acf(as.numeric(returns_daily_xts[,i]), plot=T,ylim = c(-1,1),main = title[i])
}

# acf(as.numeric(returns_daily_xts[,1]), plot=T,ylim = c(-0.2,0.2),main= "TSX") 
# acf(as.numeric(returns_daily_xts[,2]), plot=T,ylim = c(-0.2,0.2),main= "CAC") 
# acf(as.numeric(returns_daily_xts[,3]), plot=T,ylim = c(-1,1),main="CAC") 
# acf(as.numeric(returns_daily_xts[,4]), plot=T,ylim = c(-0.2,0.2),main= "Eurostoxx50") 
# acf(as.numeric(returns_daily_xts[,5]), plot=T,ylim = c(-0.2,0.2),main= "NIKKEI225") 
# acf(as.numeric(returns_daily_xts[,6]), plot=T,ylim = c(-0.2,0.2),main= "FTSE100") 
# acf(as.numeric(returns_daily_xts[,7]), plot=T,ylim = c(-1,1),main= "SP500") 
# acf(as.numeric(returns_daily_xts[,8]), plot=T,ylim = c(-0.2,0.2),main= "IBOVESPA") 

```

## Correlation Matrix 
Correlations are all positive and most of them are highly correlated except for NIKKEI225. NIKKEI225 was weakly correlated with the rest of the indexes especially SP500 which had correlation of 0.00064 with NIKKEI225. Overall, these indexes tended to move toward the same directions.
```{r}
corr_matrix = cor(log_daily_return[,-1])
corr_matrix
```
## Summary statistics of each index
Below a table was provided that summarised mean, standard deviation, skewneess, and kurtosis for each index.
```{r}
summary_stat <- rbind(mean, std_dev,ske, kurtosis)
summary_stat
```

## Summary of each index
```{r}
summary(log_daily_return[,-1])
```

## Nomrality: Evaluate whether it is reasonable to approximate the return process by i.i.d. Gaussian distribution.
To examine whether it was reasonable to approximate the return process by i.i.d Gaussian distribution, distributions of log return and original return were plotted below. In addition,shapiro wilk test was conducted and according to the insignificant p-value resulting from the test, null hypothesis stating that return data were normally distributed could be rejected. In addition, distribution of returns were mostly negative skewed with high kurtosis which illustrates that the return data of the given indexes did not follow normal distribution. Therefore, it was not reasonable to approximate the return process by i.i.d Gaussian distribution.

```{r}
# hgA <- hist(log_daily_return[,2], plot = FALSE) # Save first histogram data
# hgB <- hist(log_daily_return[,3], plot = FALSE) # Save 2nd histogram data
# plot(hgA, col = "red50") # Plot 1st histogram using a transparent color
# plot(hgB, col = "blue50", add = TRUE) # Add 2nd histogram using different color
# Log return plot
plot(density(log_daily_return[,2]),xlim= c(-0.2,0.2),ylim = c(0,100), main = "Distribution of Log Daily Returns of All Indexes")
lines(density(log_daily_return[,3]))
lines(density(log_daily_return[,4]))
lines(density(log_daily_return[,5]))
lines(density(log_daily_return[,6]))
lines(density(log_daily_return[,7]))
lines(density(log_daily_return[,8]))
lines(density(log_daily_return[,9]))


# Normal return plot
plot(density(daily_return[,2]),xlim= c(-0.2,0.2),ylim = c(0,100),col="red", main = "Distribution of Daily Returns of All Indexes")
lines(density(daily_return[,2]),col= "red")
lines(density(daily_return[,3]),col= "red")
lines(density(daily_return[,4]),col= "red")
lines(density(daily_return[,5]),col= "red")
lines(density(daily_return[,6]),col= "red")
lines(density(daily_return[,7]),col= "red")
lines(density(daily_return[,8]),col= "red")
lines(density(daily_return[,9]),col= "red")

# shapiro wilk test
for (i in 2:9){
  print(shapiro.test(log_daily_return[,i]))
}

```
\newpage

# Mean Variance Analysis

```{r}
library(ggplot2)
library(fPortfolio)
library(quadprog) # for portfolio
```
## Situation 1: short selling allowed
In this part, I assumed risk free rate is 0 and there were 252 trading days each year.
Firstly, data were annualised.
```{r}
# covariance matrix and mean for normal return and annualized them (assume 252 trading days)
nor_daily_return<- daily_return[,-1] # exclude 1st col of daily_return
# annulised covariance matrix
nor_cov_matrix <- 252*cov(na.omit(nor_daily_return))
# annualised mean
nor_mean <- ((1+colMeans(nor_daily_return,na.rm = TRUE))^252)-1  
```

Tangency portfolio would be created by two ways.
(1) Manual calculation
```{r echo=FALSE, out.width='100%', message=FALSE}
install.packages("knitr")
library(knitr)
knitr::include_graphics(path="C:/GitHub_Debbie/Projects/Project02/tangencyportfolioformula.png.")
```

```{r}
#Find the tangency portfolio
# using matrix way to calculate the weights
Sigma <- nor_cov_matrix
R <- nor_mean
w <- solve(Sigma) %*% R
w <- w/sum(w)
w
```

(2) R packages
```{r}
# using solve.QP to get the weights
# solve quadratic problem
Dmat <- nor_cov_matrix
dvec <- matrix(nor_mean,nrow = 8,ncol = 1)
Amat <- t(matrix(1,1,8))
bvec <- c(1)
optimal_weights1 <-solve.QP(Dmat,dvec,Amat,bvec,meq = 1)
optimal_weights1$solution
```
As shown above, these two ways gave us similar results of the tangency portfolio. I also noticed that, the values of some assets were extreme. For example, Eurostoxx50 had almost 1400% short position. Therefore, adding no short selling constraint should be considered. 

## Situation 2: short selling disallowed
### Portfolio weight for minimum variance portfolio
```{r}
# Minimum variance portfolio
Amat_2 <- cbind(Amat,diag(8))
bvec_2 <- c(1,rep(0,8))

optimal_weights2 <- solve.QP(Dmat,dvec,Amat=Amat_2 ,bvec=bvec_2,meq = 1)
optimal_weights2$solution
min_var_port <- setNames(optimal_weights2$solution, c(colnames(daily_return[,-1])))
min_var_port
```
As shown above, the constrained tangency portfolio was more realistic with reasonable weights of some assets comparing to the unconstrained tangency portfolio. 

### Portfolio weight for tangency portfolio
```{r}
# Tangency portfolio
time_series_return=as.timeSeries(daily_return,na.rm = TRUE)
tangencyPortfolio(as.timeSeries(na.omit(time_series_return)),constraints = "LongOnly")
```

## Plotting efficient frontier
The efficient frontier was as follow. The blue dot represented the tangency portfolio and the red dot represented the minimum variance portfolio.
```{r}
# plot Efficient frontier
frontier2 <- minvariancePortfolio(na.omit(time_series_return))
frontier_plot <- frontierPlot(portfolioFrontier(data = na.omit(time_series_return)))
grid() # add grid to existing plot
minvariancePoints(frontier2,col="red",pch=20) # highlight the minimum variance point; pch=20 is a bullet
tangencyPoints(frontier2,col="green", pch=20) # highlight the tangency portfolio point
cmlPoints(frontier2,col="blue",pch=4) # highlight the capital market portfolio point; pch=4 is a cross
tangencyLines(frontier2,col="red")
```
By adding the non-shorting-selling constraint, we get a more realistic efficient frontier with the tangency portfolio.

\newpage
# Mean Variance Analysis With Rolling Window of Five Years

```{r}
## Clean and sort data 
library(quadprog) # for portfolio
## Compute list of means and list of covariance matrix based on 5-year rolling window
begindates = c("2000-01-01","2001-01-01","2002-01-01","2003-01-01","2004-01-01","2005-01-01","2006-01-01","2007-01-01","2008-01-01","2009-01-01","2010-01-01","2011-01-01")
enddates = c("2004-12-31","2005-12-31","2006-12-31","2007-12-31","2008-12-31","2009-12-31","2010-12-31","2011-12-31","2012-12-31","2013-12-31","2014-12-31","2015-12-31")
# calculate meam and covariance for each time window 
listofreturns = list()
for (i in 1:length(begindates))
  listofreturns[[i]] = daily_return %>% filter(daily_return$date >= begindates[i] & daily_return$date <= enddates[i])

listofmeans = list()
for (i in 1:length(listofreturns)) # i = 1,2,...,12, meaning there are 12 time windows
  {
  listofmeans[[i]] = colMeans(as.matrix(listofreturns[[i]][-c(1)]), na.rm = T)
}

listofcov = list()
for (i in 1:length(listofreturns))
  {
  listofcov[[i]] = cov(na.omit(as.matrix(listofreturns[[i]][-c(1)])))
}

## Allow short sell 
w_roll <- matrix(ncol = 12, nrow = 8) # Create an empty matrix 
for (i in 1:12){
  w1 <- solve(listofcov[[i]])%*%listofmeans[[i]] # matrix_8x8 %*% matrix_8x1 >> matrix_8x1
  w_roll[,i] <- w1
}
colnames(w_roll) <- c("Period 1","Period 2","Period 3","Period 4","Period 5","Period 6","Period 7","Period 8","Period 9","Period 10","Period 11","Period 12")
rownames(w_roll) <- c("TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA")
```

## Find the minimum variance portfolio (Short sell allowed)
```{r}
mv_roll <- matrix(ncol = 8, nrow = 12) # Create an empty matrix 
for (i in 1:12){
  Dmat2 <- listofcov[[i]]
  dvec2 <- matrix(listofmeans[[i]],nrow = 8,ncol = 1)
  Amat2 <- t(matrix(1,1,8))
  bvec2 <- c(1)
  optimal_weights2 <-solve.QP(Dmat2,dvec2,Amat2,bvec2,meq = 1)
  mv_roll[i,] <- optimal_weights2$solution
}
rownames(mv_roll) <- c("2004-01-01","2005-01-01","2006-01-01","2007-01-01","2008-01-01","2009-01-01","2010-01-01","2011-01-01","2012-01-01","2013-01-01","2014-01-01","2015-01-01")
colnames(mv_roll) <- c("TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA")
mv_roll

```
## Find the minimum variance portfolio (Short sell prohibited)
```{r}
mv_roll_noshort <- matrix(ncol = 8, nrow = 12) # Create an empty matrix 
for (i in 1:12){
  Dmat2 <- listofcov[[i]]
  dvec2 <- matrix(listofmeans[[i]],nrow = 8,ncol = 1)
  A_roll <- cbind(Amat2,diag(8))
  b_roll <- c(1,rep(0,8))
  optimal_weights_roll <- solve.QP(Dmat2,dvec2,Amat=A_roll ,bvec=b_roll,meq = 1)
  mv_roll_noshort[i,] <- optimal_weights_roll$solution
}
rownames(mv_roll_noshort) <- c("2004-01-01","2005-01-01","2006-01-01","2007-01-01","2008-01-01","2009-01-01","2010-01-01","2011-01-01","2012-01-01","2013-01-01","2014-01-01","2015-01-01")
colnames(mv_roll_noshort) <- c("TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA")
mv_roll_noshort
```

## Examine if this portfolio is significantly time-varying
From the graph below, it is obvious that index weights within mean-variance portfolio that allows short selling vary to a larger extent than non-shortselling portfolio. Moreover, ranges of weights of NIKKI225 and Eurostoxx50 are a lot greater than the rest. For non-shortselling portfolio, index weights from 2006 to 2011 appeared to be relatively stable while for shortselling portfolio, weights became stable after 2008. 
```{r}
### M-V (no short selling)
# Organise data 
mv_roll_noshort_df <- as.data.frame(mv_roll_noshort)
mydf <- cbind(rownames(mv_roll_noshort_df), mv_roll_noshort_df)
rownames(mydf) <- NULL
colnames(mydf) <- c("Year","TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA")
# convert to timeseries 
mv_roll_noshort_xts <- xts(mydf, order.by = as.Date(mydf$Year),format = '%Y-%m-%d' )
zoo.basket <- as.zoo(mv_roll_noshort_xts)
tsRainbow <- rainbow(ncol(zoo.basket))
plot(x = zoo.basket, ylab = "Weight", main = "Weight for non-short selling portfolio",col = tsRainbow, screens = 1,ylim = c(-3,3))
legend(x = 'topleft', legend = c("TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA"),
       lty = 1,col = tsRainbow,cex = 0.5)

### M-V (short selling allowed)
# Organise data 
mv_roll_df <- as.data.frame(mv_roll)
mydf2 <- cbind(rownames(mv_roll_df), mv_roll_df)
rownames(mydf2) <- NULL
colnames(mydf2) <- c("Year","TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA")
# convert to timeseries 
mv_roll_xts <- xts(mydf2, order.by = as.Date(mydf2$Year),format = '%Y-%m-%d' )
zoo.basket2 <- as.zoo(mv_roll_xts)
tsRainbow2 <- rainbow(ncol(zoo.basket2))
plot(x = zoo.basket2, ylab = "Weight", main = "Weight for portfolio (short selling)",col = tsRainbow, screens = 1,ylim = c(-30,30))
legend(x = 'topleft', legend = c("TSX","CAC","DAX","Eurostoxx50","NIKKI225","FTSE100","SP500","IBOVESPA"),
       lty = 1,col = tsRainbow2,cex = 0.5)
```

## Compare Market-based weights and Mean-Variance weights
Weights calculated by market capital and mean-variance approaches varies in a large degree. By allowing short selling, composition weight of portfolio deviates from strategies that prohibit short selling even more.  
```{r}
Mktcap_data <- read_excel("PS1_data.xls",sheet ="market_cap", skip = 1)
Mktcap_weight <- Mktcap_data[5,]

# Compare market-cap weights and mean-variance weights
MV_weight_short <- optimal_weights1$solution
MV_weight_noshort <- optimal_weights2$solution
comparison <- rbind(Mktcap_weight,MV_weight_short,MV_weight_noshort)
comparison <- as.data.frame(comparison)
rownames(comparison) <- c("Market-Cap Weight","Mean-Variance Weight (with short sale)","Mean-Variance Weight (without short sale)" )
comparison

```





